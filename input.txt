Mongo document structure

{
  "_id": "<ObjectId>",
  "workflow_pattern": "workflowA*",    // Workflow wildcard pattern
  "caller_pattern": "agentA*",         // Caller wildcard pattern
  "callee_pattern": "agentB123",       // Callee wildcard pattern
  "effect": "allow",                   // "allow" or "deny"
  "priority": 10,                     // Priority for conflict resolution
  "description": "Allow caller in workflowA* to call agentB123"
}


========

Load redis rules to mongo



import pymongo
import redis
import json

# Connect to MongoDB and Redis
mongo_client = pymongo.MongoClient("mongodb://localhost:27017")
db = mongo_client["agent_auth_db"]
rules_collection = db["access_rules"]

redis_client = redis.Redis(host='localhost', port=6379, db=0)

def load_rules_to_redis():
    rules = list(rules_collection.find({}))
    # Clear existing rules in Redis
    redis_client.delete("agent_access_rules")

    # Store as a JSON list string for simplicity
    rules_json = json.dumps([{
        "caller_pattern": r["caller_pattern"],
        "callee_pattern": r["callee_pattern"],
        "effect": r["effect"],
        "priority": r.get("priority", 0)
    } for r in rules])

    redis_client.set("agent_access_rules", rules_json)

if __name__ == "__main__":
    load_rules_to_redis()


========

Rules validator

import redis
import json
import fnmatch

redis_client = redis.Redis(host='localhost', port=6379, db=0)

def check_access(workflow: str, caller: str, callee: str) -> bool:
    rules_json = redis_client.get("agent_access_rules")
    if not rules_json:
        # No rules loaded: default deny
        return False

    rules = json.loads(rules_json)
    deny_rules = [r for r in rules if fnmatch.fnmatch(callee, r["callee_pattern"]) and r["effect"] == "deny"]
    allow_rules = [r for r in rules if fnmatch.fnmatch(callee, r["callee_pattern"]) and r["effect"] == "allow"]

    # Check deny rules first: deny immediately if matched
    for rule in deny_rules:
        if fnmatch.fnmatch(workflow, rule["workflow_pattern"]) and fnmatch.fnmatch(caller, rule["caller_pattern"]):
            return False  # Deny and exit immediately

    allow_list = []
    for rule in allow_rules:
        # Workflow pattern must be '*' or match current workflow
        if rule["workflow_pattern"] == "*" or fnmatch.fnmatch(workflow, rule["workflow_pattern"]):
            # If caller does not match the rule's caller pattern, deny and exit
            if fnmatch.fnmatch(caller, rule["caller_pattern"]):
              allow_list.append(rule)

    # Allow if at least one allow rule matched; otherwise deny
    return len(allow_list) > 0

# Example usage
if __name__ == "__main__":
    tests = [
        ("workflowA1", "agentA123", "agentB123"),
        ("workflowX", "agentX", "anyagent"),
    ]

    for wf, caller_agent, callee_agent in tests:
        can_call = check_access(wf, caller_agent, callee_agent)
        print(f"Workflow: {wf}, Caller: {caller_agent}, Callee: {callee_agent}, Access allowed: {can_call}")



