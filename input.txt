flowchart TD
    A([User Login to Studio])
    B([Go to Control Plane])
    C([Trigger Agent Start])
    D([Agent: Start Process])
    E([Lookup Dependencies<br>from JSON File])
    F([Fetch Running Agents<br>from Agentic Registry])
    G([Configure Fetched Agents])
    H([Fetch Running MCP Servers])
    I([Configure MCP Servers])
    J([Register Agent<br>in Registry])
    K([Agent Ready to<br>Take Traffic])

    A --> B
    B --> C
    C --> D
    D --> E
    E --> F
    F --> G
    G --> H
    H --> I
    I --> J
    J --> K



import base64
import json
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization

def base64url_to_int(val):
    """Convert base64url string to integer."""
    val += '=' * ((4 - len(val) % 4) % 4)  # padding
    decoded = base64.urlsafe_b64decode(val)
    return int.from_bytes(decoded, 'big')

def jwk_to_pem(jwk):
    """Convert RSA JWK to PEM public key."""
    n = base64url_to_int(jwk['n'])
    e = base64url_to_int(jwk['e'])
    public_numbers = rsa.RSAPublicNumbers(e, n)
    public_key = public_numbers.public_key()
    pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )
    return pem

# Example usage:
jwks = {
  # your JWKS fetched from https://issuer/.well-known/jwks.json
}

kid = 'kid-from-jwt-header'
key = None
for k in jwks['keys']:
    if k['kid'] == kid:
        key = k
        break

if key:
    pem_key = jwk_to_pem(key)
    # Now use pem_key (bytes) as the public key in PyJWT decode
    # e.g., jwt.decode(token, pem_key, algorithms=['RS256'], options={...})




import functools
import jwt
from fastmcp import MCPError, request_context

SECRET_KEY = "your-signing-secret"     # Or load from env/KeyVault
ALGORITHM = "HS256"
ISSUER = "https://auth.example.com"

def authenticate(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        auth_header = request_context.headers.get("Authorization", "")
        if not auth_header.startswith("Bearer "):
            raise MCPError(401, "Missing or invalid Authorization header")
        token = auth_header.split(" ", 1)[1]
        try:
            claims = jwt.decode(
                token,
                SECRET_KEY,
                algorithms=[ALGORITHM],
                issuer=ISSUER,
                options={"require": ["exp", "iss", "sub"]}
            )
        except jwt.ExpiredSignatureError:
            raise MCPError(401, "Token has expired")
        except jwt.InvalidTokenError as e:
            raise MCPError(401, f"Invalid token: {str(e)}")
        # Attach claims to context for downstream use
        request_context.user = claims["sub"]
        request_context.entitlements = set(claims.get("entitlements", []))
        return func(*args, **kwargs)
    return wrapper


def require_entitlement(entitlement_name: str):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            user_ent = getattr(request_context, "entitlements", set())
            if entitlement_name not in user_ent:
                raise MCPError(403, f"Missing entitlement: {entitlement_name}")
            return func(*args, **kwargs)
        return wrapper
    return decorator


from fastmcp import tool

@tool("list_tools")
@authenticate
@require_entitlement("tools:list")
def list_tools():
    # business logic to list available tools
    return {"tools": [...]}

@tool("execute_tool")
@authenticate
@require_entitlement("tools:execute")
def execute_tool(tool_name: str, params: dict):
    # business logic for tool execution
    result = run_tool(tool_name, params)
    return {"result": result}


jwt.encode({
    "sub": user_id,
    "iss": ISSUER,
    "exp": expiration_timestamp,
    "entitlements": ["tools:list", "tools:execute", ...]
}, SECRET_KEY, algorithm=ALGORITHM)


