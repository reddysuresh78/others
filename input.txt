import asyncio
from typing import Dict, Any, List, Tuple, Optional
import os

from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client

from langchain_mcp_adapters.tools import load_mcp_tools
from langgraph.prebuilt import create_react_agent
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemoryCheckpoint

from langchain_openai import ChatOpenAI

# Define a class to manage the MCP client
class MCPClientManager:
    def __init__(self, server_params: StdioServerParameters):
        self.server_params = server_params
        self.read = None
        self.write = None
        self.session = None
        self.tools = None
        self.client_context = None

    async def initialize(self):
        """Initialize the MCP client and session"""
        if self.session is not None:
            return
        
        # Create the stdio client
        client_context = stdio_client(self.server_params)
        await client_context.__aenter__()
        self.read, self.write = client_context.__enter__()
        self.client_context = client_context
        
        # Create and initialize the session
        self.session = ClientSession(self.read, self.write)
        await self.session.__aenter__()
        await self.session.initialize()
        
        # Load tools
        self.tools = await load_mcp_tools(self.session)
        
        return self.tools

    async def close(self):
        """Close the session and client"""
        if self.session is not None:
            await self.session.__aexit__(None, None, None)
            self.session = None
        
        if self.client_context is not None:
            self.client_context.__exit__(None, None, None)
            await self.client_context.__aexit__(None, None, None)
            self.client_context = None
            self.read = None
            self.write = None

# Define our state structure
class State(Dict[str, Any]):
    """
    State for our MCP-powered agent
    
    Attributes:
        messages: List of messages in the conversation
        response: The agent's response
        error: Any error that occurred
    """
    messages: List[Dict[str, str]]
    response: Optional[Dict[str, Any]]
    error: Optional[str]

# Create the MCP client manager
server_params = StdioServerParameters(
    command="python",
    # Make sure to update to the full absolute path to your math_server.py file
    args=[os.path.expanduser("~/math_server.py")],  # Update this path
)
mcp_client_manager = MCPClientManager(server_params)

# Define nodes for our graph
async def initialize_tools(state: State) -> Dict[str, Any]:
    """Initialize the MCP tools if not already initialized"""
    try:
        tools = await mcp_client_manager.initialize()
        return {"error": None}
    except Exception as e:
        return {"error": f"Failed to initialize MCP tools: {str(e)}"}

async def process_request(state: State) -> Dict[str, Any]:
    """Process the request using the ReAct agent"""
    if state.get("error"):
        return state
    
    try:
        # Get the last user message
        last_message = next((msg["content"] for msg in reversed(state["messages"]) 
                           if msg.get("role") == "user"), "")
        
        if not last_message:
            return {"error": "No user message found"}
        
        # Create the language model
        model = ChatOpenAI(model="gpt-4o")
        
        # Create the agent
        agent = create_react_agent(model, mcp_client_manager.tools)
        
        # Invoke the agent
        agent_response = await agent.ainvoke({"messages": last_message})
        
        # Format the response
        assistant_message = {
            "role": "assistant",
            "content": agent_response["messages"][-1].content
        }
        
        # Add to messages
        new_messages = state["messages"] + [assistant_message]
        
        return {
            "messages": new_messages,
            "response": agent_response,
            "error": None
        }
    except Exception as e:
        return {"error": f"Error processing request: {str(e)}"}

async def handle_error(state: State) -> Dict[str, Any]:
    """Handle any errors that occurred"""
    error_message = {
        "role": "assistant",
        "content": f"An error occurred: {state['error']}"
    }
    
    new_messages = state["messages"] + [error_message]
    
    return {
        "messages": new_messages
    }

# Define the graph
def build_mcp_agent_graph():
    """Build the graph for our MCP-powered agent"""
    graph = StateGraph(State)
    
    # Add nodes
    graph.add_node("initialize_tools", initialize_tools)
    graph.add_node("process_request", process_request)
    graph.add_node("handle_error", handle_error)
    
    # Add edges
    graph.add_edge("initialize_tools", "process_request")
    
    # Add conditional edges
    graph.add_conditional_edges(
        "initialize_tools",
        lambda state: "handle_error" if state.get("error") else "process_request",
        {
            "handle_error": "handle_error",
            "process_request": "process_request"
        }
    )
    
    graph.add_conditional_edges(
        "process_request",
        lambda state: "handle_error" if state.get("error") else END,
        {
            "handle_error": "handle_error"
        }
    )
    
    # Set the entry point
    graph.set_entry_point("initialize_tools")
    
    return graph

# Example usage
async def main():
    try:
        # Create and compile the graph
        graph = build_mcp_agent_graph()
        checkpoint = MemoryCheckpoint()
        app = graph.compile(checkpointer=checkpoint)
        
        # Process multiple requests in sequence
        request1 = {
            "messages": [{"role": "user", "content": "what's (3 + 5) x 12?"}]
        }
        
        request2 = {
            "messages": [{"role": "user", "content": "what's the square root of 144?"}]
        }
        
        # Process the first request
        print("Processing first request...")
        result1 = await app.ainvoke(request1)
        print(f"Result 1: {result1['messages'][-1]['content']}")
        
        # Process the second request (reusing the same MCP client)
        print("\nProcessing second request...")
        result2 = await app.ainvoke(request2)
        print(f"Result 2: {result2['messages'][-1]['content']}")
        
    finally:
        # Close the MCP client
        await mcp_client_manager.close()

if __name__ == "__main__":
    asyncio.run(main())
