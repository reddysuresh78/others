from playwright.sync_api import sync_playwright
import json

def generate_locator(element):
    element_id = element.get_attribute("id")
    element_class = element.get_attribute("class")
    tag_name = element.evaluate("el => el.tagName.toLowerCase()")
    if element_id:
        locator = f"#{element_id}"
    elif element_class:
        first_class = element_class.split()
        locator = f"{tag_name}.{first_class}"
    else:
        locator = tag_name
    return locator

def extract_interactive_locators(page):
    interactive_elements = {}
    selector_map = [
        {"type": "button", "selector": "button"},
        {"type": "link", "selector": "a[href]"},
        {"type": "input", "selector": "input"},
        {"type": "textarea", "selector": "textarea"},
        {"type": "select", "selector": "select"},
        {"type": "checkbox", "selector": "input[type='checkbox']"},
        {"type": "radio", "selector": "input[type='radio']"},
    ]
    for item in selector_map:
        elements = page.query_selector_all(item["selector"])
        for el in elements:
            locator = generate_locator(el)
            name = (el.text_content() or "").strip()
            # Ignore elements with empty locator or name
            if locator and name:
                # If duplicate keys, could add a suffix or skip
                if name not in interactive_elements:
                    interactive_elements[name] = {
                        "type": item["type"],
                        "locator": locator
                    }
    return interactive_elements

def main(url, output_file='interactive_elements.json'):
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True)
        page = browser.new_page()
        page.goto(url)
        interactive_elements = extract_interactive_locators(page)
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(interactive_elements, f, ensure_ascii=False, indent=2)
        browser.close()

# Example usage:
# main('https://www.example.com', 'output.json')



#type script version

import { chromium, Page } from 'playwright';
import * as fs from 'fs';

function generateLocator(element: Element): string {
  const elementId = element.getAttribute('id');
  const elementClass = element.getAttribute('class');
  const tagName = element.tagName.toLowerCase();
  if (elementId) {
    return `#${elementId}`;
  } else if (elementClass) {
    const firstClass = elementClass.split(' ');
    return `${tagName}.${firstClass}`;
  } else {
    return tagName;
  }
}

async function extractInteractiveLocators(page: Page): Promise<Record<string, { type: string, locator: string }>> {
  const selectorMap = [
    { type: 'button', selector: 'button' },
    { type: 'link', selector: 'a[href]' },
    { type: 'input', selector: 'input' },
    { type: 'textarea', selector: 'textarea' },
    { type: 'select', selector: 'select' },
    { type: 'checkbox', selector: 'input[type="checkbox"]' },
    { type: 'radio', selector: 'input[type="radio"]' }
  ];
  const interactiveElements: Record<string, { type: string, locator: string }> = {};

  for (const item of selectorMap) {
    const elements = await page.$$(item.selector);

    for (const elHandle of elements) {
      const locator = await elHandle.evaluate(generateLocator);
      const name = (await elHandle.textContent())?.trim() ?? '';

      // Only include if both name and locator are non-empty and name is unique
      if (locator && name && !(name in interactiveElements)) {
        interactiveElements[name] = {
          type: item.type,
          locator
        };
      }
    }
  }
  return interactiveElements;
}

(async () => {
  const browser = await chromium.launch({ headless: true });
  const page = await browser.newPage();
  await page.goto('https://www.example.com');

  const interactiveElements = await extractInteractiveLocators(page);

  fs.writeFileSync('interactive_elements.json', JSON.stringify(interactiveElements, null, 2), 'utf-8');

  await browser.close();
})();



#Prompt

Here is a **consolidated prompt** suitable for any LLM (including GPT, Claude, Gemini, or enterprise models) that describes the entire workflow step-by-step and requests a cross-language solution for extracting interactive elements from a web page using Playwright, outputting a JSON object where keys are the visible text and values are the type and locator of each element:[9][10][11][12]

***

### Consolidated LLM Prompt

**Goal:**  
Generate code to extract all interactive UI elements from a web page (such as buttons, links, inputs, selects, radios, and checkboxes) using Playwright in either Python or TypeScript. The output should be a JSON object where each key is the visible text ("name") of an element, and the value is an object containing `"type"` and `"locator"` for that element. Only include elements where both the visible text and locator are non-empty. Locators should prefer IDs, else class (first class name), else fallback to tag name.

**Details:**
- Interactive elements: `button`, `a[href]`, `input`, `textarea`, `select`, `input[type="checkbox"]`, `input[type="radio"]`
- "name" = visible text content of the element (`textContent`, trimmed)
- "locator" = prioritize:
  1. ID attribute (`#id`)
  2. First class name (`tag.class`)
  3. Tag name (`tag`)
- Only include elements with non-empty name and non-empty locator
- Output JSON where:  
  ```json
  {
    "elementName": {
      "type": "button",
      "locator": "#submit"
    },
    "otherElement": {
      "type": "link",
      "locator": "a.nav"
    }
  }
  ```
- Ignore duplicate names or handle them by appending an index if necessary

**Requirements:**
- LLM should respond with runnable Playwright code in the requested language
- Python code must use `playwright.sync_api` and TypeScript code must use async/await logic
- Output JSON formatted as above
- Comment the code for clarity
- Do not add extraneous explanationâ€”only code and minimal context as needed

**Example:**
> Write Playwright code (in **Python** or **TypeScript**) that:
> - Launches Chromium
> - Navigates to a given URL
> - Extracts all interactive elements by the rules above
> - Outputs a JSON file as described, mapping each element's visible text to `{type, locator}`

***

This prompt is comprehensive and ready for any LLM to generate the working code in either Python or TypeScript for the described UI extraction task.[10][11][12][9]

[1](https://playwright.dev/docs/test-typescript)
[2](https://www.lambdatest.com/blog/playwright-end-to-end-testing/)
[3](https://www.youtube.com/watch?v=zfLOSJmkZiE)
[4](https://brightdata.com/blog/ai/web-scraping-with-llm-scraper)
[5](https://jignect.tech/enhancing-api-automation-testing-with-playwright-and-typescript-get-and-post-operations-explained/)
[6](https://www.scribd.com/document/861225550/Playwright-TypeScript-Full-Course-by-Testers-Talk)
[7](https://www.linkedin.com/pulse/test-automation-unleashing-power-ai-playwright-typescript-nir-tal-nd1yf)
[8](https://www.youtube.com/watch?v=788GvvcfwTY)
[9](https://bugbug.io/blog/testing-frameworks/playwright-locators/)
[10](https://www.browserstack.com/guide/playwright-selectors)
[11](https://stackoverflow.com/questions/75151754/how-can-i-select-an-element-by-id)
[12](https://www.codekru.com/playwright/how-to-get-the-text-of-an-element-using-the-playwright)
